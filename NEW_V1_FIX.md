# NEW_V1 固件协议修复说明

## 问题诊断

根据你提供的调试日志，水控器使用的是 **NEW_V1** 固件版本，通信流程如下：

```
1. TXD: FEFE09B001010000              (发送初始握手请求)
2. RXD: FDFD09B04F3D030B036F8E...     (接收0xb0握手响应)
3. RXD: FDFD09AE5207DC1F84...         (接收0xae密钥请求)
4. TXD: FEFE09AFB807DC20D10E...       (发送0xaf认证响应)
5. RXD: FDFD09AF7A01010201...         (接收0xaf包中的0x7A确认)
```

## 问题原因

之前的协议适配器只处理了 `0x7A` 和 `0x8E` 数据包，但 NEW_V1 固件的完整握手流程包含：

- **0xb0** - 初始握手响应
- **0xae** - 密钥请求
- **0xaf** - 认证响应
- **0x7A** - 最终认证确认

当适配器拦截这些包时，原有的认证逻辑无法正常执行，导致"水控器拒绝启动"错误。

## 解决方案

### 修改内容

1. **更新固件检测逻辑** (`detectFirmwareVersion`)
   - 添加对 `0xb0`、`0xae`、`0xaf` 的检测
   - 这些特征码表明是 NEW_V1 固件

2. **修改 NEW_V1 协议处理** (`handleNewV1Protocol`)
   - 对于 `0xb0`、`0xae`、`0xaf` 数据包，**返回 false**
   - 这样让原有的认证逻辑处理这些关键包
   - 只在特殊情况下才拦截 `0x7A` 和 `0x8E`

### 技术原理

```typescript
switch (dType) {
  case 0xb0: // 初始握手
  case 0xae: // 密钥请求
  case 0xaf: // 认证响应
    log("忽略握手包，由原有逻辑处理");
    return false; // 不拦截，让原代码处理
  case 0x7A:
  case 0x8E:
    // 只在需要时处理这些特殊包
    return await this.handleSpecialCase(...);
  default:
    return false;
}
```

## 测试步骤

1. 重新构建项目：
   ```bash
   npm run build
   ```

2. 打开 `dist/index.html`

3. 点击"开启"按钮连接水控器

4. 观察调试信息：
   - 应该看到"忽略0xb0/0xae/0xaf握手包"的日志
   - 认证流程应该正常完成
   - 不应该再出现"水控器拒绝启动"错误

## 预期结果

修复后的通信流程：

```
✅ 协议适配器初始化
✅ 检测到固件版本: NEW_V1
✅ TXD: FEFE09B001010000
✅ RXD: FDFD09B04F3D... (0xb0)
   ↳ 忽略，由原有逻辑处理
✅ RXD: FDFD09AE... (0xae)
   ↳ 忽略，由原有逻辑处理
✅ TXD: FEFE09AFB807...
✅ RXD: FDFD09AF7A... (0xaf中包含0x7A)
   ↳ 忽略，由原有逻辑处理
✅ 认证成功，水控器启动
```

## 兼容性说明

此修复保持了与以下固件版本的兼容性：

- **NEW_V1** - 使用 0xb0/0xae/0xaf 握手序列（本次修复目标）
- **NEW_V2** - 使用 0x98/0x04 扩展协议
- **LEGACY** - 传统固件版本

## 如果仍然出现问题

如果修复后仍然无法连接，请提供：

1. 完整的调试日志（从开始连接到出错）
2. 水控器型号和固件版本信息
3. 错误截图

可以通过以下方式获取更详细的日志：

1. 打开浏览器开发者工具 (F12)
2. 切换到 Console 标签
3. 点击"开启"连接水控器
4. 复制所有日志信息

---

**修复日期**: 2025年10月8日  
**修复版本**: v0.0.1  
**影响范围**: NEW_V1 固件的水控器连接问题
