<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="build-version" content="2025-01-08-05" />
    <meta name="cache-control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="pragma" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <link rel="icon" href="favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="æ·±åœ³å¸‚å¸¸å·¥ç”µå­&quot;è“ç‰™æ°´æ§å™¨&quot;æ§åˆ¶ç¨‹åºçš„å¼€æºå®ç°ã€‚é€‚ç”¨äºå›½å†…å„å¤§é«˜æ ¡å®¿èˆçƒ­æ°´å™¨ã€‚" />
    <meta name="theme-color" content="#fafafa" />
    <link rel="apple-touch-icon" href="logo192.png" />
    <link rel="manifest" href="manifest.json" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css">
    <title>è“ç‰™æ°´æ§å™¨ FOSS</title>
    <style>
      /* å¼ºåˆ¶è¦†ç›–water.cssçš„é»˜è®¤æ ·å¼ */
      body {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
        background-attachment: fixed !important;
        min-height: 100vh !important;
        margin: 0 !important;
        padding: 0 !important;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;
        overflow-x: hidden !important;
      }

      .main {
        position: absolute !important;
        left: 50% !important;
        top: 50% !important;
        -webkit-transform: translate(-50%, -50%) !important;
        transform: translate(-50%, -50%) !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        flex-direction: column !important;
        background: rgba(255, 255, 255, 0.15) !important;
        backdrop-filter: blur(15px) !important;
        -webkit-backdrop-filter: blur(15px) !important;
        border-radius: 25px !important;
        padding: 40px 50px !important;
        border: 2px solid rgba(255, 255, 255, 0.3) !important;
        box-shadow: 0 15px 45px rgba(0, 0, 0, 0.2) !important;
        min-width: 350px !important;
        max-width: 500px !important;
        text-align: center !important;
        margin: 0 !important;
      }

      .main h2 {
        color: white !important;
        text-shadow: 0 3px 6px rgba(0, 0, 0, 0.4) !important;
        margin-top: 0 !important;
        margin-bottom: 15px !important;
        font-size: 28px !important;
        font-weight: 700 !important;
      }

      .main button {
        background: linear-gradient(45deg, #667eea, #764ba2) !important;
        color: white !important;
        border: none !important;
        padding: 12px 30px !important;
        border-radius: 25px !important;
        font-size: 16px !important;
        font-weight: 600 !important;
        cursor: pointer !important;
        transition: all 0.3s ease !important;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2) !important;
        margin: 10px 0 !important;
        pointer-events: auto !important;
        user-select: none !important;
        -webkit-user-select: none !important;
        -webkit-tap-highlight-color: transparent !important;
        position: relative !important;
        z-index: 1 !important;
      }

      .main button:hover {
        transform: translateY(-2px) !important;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3) !important;
        background: linear-gradient(45deg, #5a8ff0, #8959b8) !important;
      }

      .main button:active {
        transform: translateY(0px) !important;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2) !important;
      }

      .main button:disabled {
        opacity: 0.6 !important;
        cursor: not-allowed !important;
        pointer-events: none !important;
      }

      /* ç§»é™¤.mainçš„pointer-eventsè®¾ç½®ï¼Œé¿å…é˜»æ­¢æŒ‰é’®ç‚¹å‡» */
      .main {
        pointer-events: auto !important;
      }

      .main p {
        color: rgba(255, 255, 255, 0.9) !important;
        margin: 8px 0 !important;
        font-size: 14px !important;
      }

      .misc {
        position: fixed !important;
        bottom: 20px !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        text-align: center !important;
      }

      .misc a {
        color: rgba(255, 255, 255, 0.7) !important;
        text-decoration: none !important;
        margin: 0 5px !important;
      }

      .misc a:hover {
        color: white !important;
        text-decoration: underline !important;
      }
    </style>
  </head>

  <body>
    <div class="main supported">
      <noscript>éœ€è¦å¯ç”¨ JavaScriptã€‚</noscript>
      <h2 style="margin-top: 0; color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">ğŸ›€ è“ç‰™æ°´æ§å™¨</h2>
      <p id="bluetooth-status" style="color: rgba(255,255,255,0.8); font-size: 14px; margin: 5px 0;">æ£€æµ‹è“ç‰™æ”¯æŒä¸­...</p>
      <button 
        id="main-button" 
        onclick="try{window.startWaterController && window.startWaterController(); console.log('âœ…HTMLå†…è”ç‚¹å‡»æˆåŠŸ');}catch(e){console.error('âŒHTMLå†…è”å¤±è´¥:',e);}"
        data-onclick="startWaterController"
        style="pointer-events: auto !important; cursor: pointer !important;">å¼€å¯</button>
      
      <!-- ğŸš° æ°´é‡æ§åˆ¶é¢æ¿ -->
      <div id="water-controls" style="display: none; margin: 20px 0; padding: 20px; background: rgba(255,255,255,0.1); border-radius: 15px; backdrop-filter: blur(10px);">
        <h3 style="color: #fff; margin: 0 0 15px 0; font-size: 18px;">ğŸ’§ æ°´é‡æ§åˆ¶</h3>
        
        <div style="margin-bottom: 15px;">
          <label style="color: rgba(255,255,255,0.9); font-size: 14px; display: block; margin-bottom: 5px;">è®¾ç½®å‡ºæ°´é‡ (æ¯«å‡):</label>
          <input type="number" id="water-amount" value="500" min="1" max="65000" style="width: 100px; padding: 5px; border-radius: 5px; border: none; text-align: center;" />
          <button onclick="setWaterAmount()" style="margin-left: 10px; padding: 5px 15px; background: linear-gradient(45deg, #4CAF50, #45a049); color: white; border: none; border-radius: 5px; font-size: 12px;">è®¾ç½®</button>
        </div>
        
        <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
          <button onclick="quickWaterAmount(100)" style="padding: 8px 12px; background: linear-gradient(45deg, #2196F3, #1976D2); color: white; border: none; border-radius: 8px; font-size: 12px; cursor: pointer;">100ml</button>
          <button onclick="quickWaterAmount(500)" style="padding: 8px 12px; background: linear-gradient(45deg, #2196F3, #1976D2); color: white; border: none; border-radius: 8px; font-size: 12px; cursor: pointer;">500ml</button>
          <button onclick="quickWaterAmount(1000)" style="padding: 8px 12px; background: linear-gradient(45deg, #2196F3, #1976D2); color: white; border: none; border-radius: 8px; font-size: 12px; cursor: pointer;">1L</button>
          <button onclick="quickWaterAmount(2000)" style="padding: 8px 12px; background: linear-gradient(45deg, #2196F3, #1976D2); color: white; border: none; border-radius: 8px; font-size: 12px; cursor: pointer;">2L</button>
        </div>
        
        <div style="margin: 15px 0;">
          <button onclick="fixErr39Error()" style="width: 100%; padding: 12px; background: linear-gradient(45deg, #4CAF50, #45a049); color: white; border: none; border-radius: 10px; font-size: 14px; font-weight: bold; cursor: pointer;">ï¿½ PASSçŠ¶æ€ç ´è§£</button>
        </div>
        
        <div style="margin: 15px 0;">
          <button onclick="activateUnlimitedMode()" style="width: 100%; padding: 12px; background: linear-gradient(45deg, #FF9800, #F57C00); color: white; border: none; border-radius: 10px; font-size: 14px; font-weight: bold; cursor: pointer;">â™¾ï¸ æ¿€æ´»æ— é™æ¨¡å¼</button>
        </div>
        
        <div style="margin-top: 15px;">
          <button onclick="emergencyStop()" style="width: 100%; padding: 12px; background: linear-gradient(45deg, #f44336, #d32f2f); color: white; border: none; border-radius: 10px; font-size: 14px; font-weight: bold; cursor: pointer;">ğŸ›‘ ç´§æ€¥åœæ­¢</button>
        </div>
        
        <div id="water-status" style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px; color: rgba(255,255,255,0.9); font-size: 13px; text-align: center;">
          ğŸ’§ çŠ¶æ€: å¾…æœºä¸­
        </div>
      </div>
      
      <button 
        id="clear-pairing-button" 
        style="background: linear-gradient(45deg, #ff6b6b, #ee5a6f) !important; font-size: 14px !important; padding: 8px 20px !important; pointer-events: auto !important; cursor: pointer !important;" 
        onclick="try{window.clearPairedDevices && window.clearPairedDevices(); console.log('âœ…æ¸…é™¤æŒ‰é’®HTMLå†…è”æˆåŠŸ');}catch(e){console.error('âŒæ¸…é™¤æŒ‰é’®HTMLå†…è”å¤±è´¥:',e);}"
        data-onclick="clearPairedDevices">æ¸…é™¤å·²é…å¯¹è®¾å¤‡</button>
      <p id="device-name" style="margin-top: 10px; margin-bottom: 10px">æœªè¿æ¥</p>
    </div>
    
    <script>
      // ç«‹å³æ‰§è¡Œè“ç‰™æ£€æµ‹ï¼Œä¸ç­‰å¾…å…¶ä»–è„šæœ¬åŠ è½½
      (function() {
        async function quickBluetoothCheck() {
          const statusEl = document.getElementById("bluetooth-status");
          if (!statusEl) {
            setTimeout(quickBluetoothCheck, 50);
            return;
          }
          
          try {
            // æ›´ä¸¥æ ¼çš„è“ç‰™æ£€æµ‹
            if (typeof navigator === 'undefined' || !navigator.bluetooth) {
              statusEl.innerHTML = "âŒ æµè§ˆå™¨ä¸æ”¯æŒè“ç‰™ API";
              statusEl.style.color = "rgba(255, 99, 71, 0.9)";
              console.log("å¿«é€Ÿè“ç‰™æ£€æµ‹ï¼šä¸æ”¯æŒï¼ˆAPIä¸å­˜åœ¨ï¼‰");
              return;
            }

            // æµ‹è¯•è“ç‰™APIæ˜¯å¦çœŸæ­£å¯ç”¨
            try {
              const availability = await navigator.bluetooth.getAvailability();
              
              if (availability) {
                statusEl.innerHTML = "âœ… è“ç‰™åŠŸèƒ½å¯ç”¨";
                statusEl.style.color = "rgba(144, 238, 144, 0.9)";
                console.log("å¿«é€Ÿè“ç‰™æ£€æµ‹ï¼šå¯ç”¨");
              } else {
                statusEl.innerHTML = "âš ï¸ è“ç‰™ç¡¬ä»¶ä¸å¯ç”¨æˆ–æœªå¼€å¯";
                statusEl.style.color = "rgba(255, 215, 0, 0.9)";
                console.log("å¿«é€Ÿè“ç‰™æ£€æµ‹ï¼šç¡¬ä»¶ä¸å¯ç”¨");
              }
            } catch (err) {
              statusEl.innerHTML = "âš ï¸ æµè§ˆå™¨æ”¯æŒè“ç‰™ï¼Œä½†æ— æ³•æ£€æµ‹ç¡¬ä»¶çŠ¶æ€";
              statusEl.style.color = "rgba(255, 215, 0, 0.9)";
              console.log("å¿«é€Ÿè“ç‰™æ£€æµ‹ï¼šAPIå­˜åœ¨ä½†æ— æ³•æ£€æµ‹ç¡¬ä»¶");
            }
          } catch (error) {
            statusEl.innerHTML = "âŒ è“ç‰™æ£€æµ‹å‡ºé”™";
            statusEl.style.color = "rgba(255, 99, 71, 0.9)";
            console.error("å¿«é€Ÿè“ç‰™æ£€æµ‹é”™è¯¯:", error);
          }
        }
        
        // ğŸš€ ç«‹å³å¼ºåˆ¶ç»‘å®šæŒ‰é’®äº‹ä»¶ - è§£å†³æ‰€æœ‰æŒ‰é’®é—®é¢˜
        function forceButtonBinding() {
          console.log("ğŸš€ å¼€å§‹å¼ºåˆ¶æŒ‰é’®ç»‘å®š...");
          
          // å¼ºåˆ¶ä¸»æŒ‰é’®ç»‘å®š
          const mainBtn = document.getElementById("main-button");
          if (mainBtn) {
            console.log("âœ… æ‰¾åˆ°ä¸»æŒ‰é’®ï¼Œå¼€å§‹å¼ºåˆ¶ç»‘å®š");
            
            // ç¡®ä¿æŒ‰é’®å¯ç‚¹å‡»
            mainBtn.style.pointerEvents = "auto";
            mainBtn.style.cursor = "pointer";
            mainBtn.disabled = false;
            
            // å¼ºåˆ¶ç‚¹å‡»å¤„ç†å™¨
            const mainClickHandler = function(e) {
              console.log("ğŸ¯ ä¸»æŒ‰é’®å¼ºåˆ¶ç‚¹å‡»å¤„ç†å™¨è§¦å‘ï¼", e.type);
              e.preventDefault();
              e.stopPropagation();
              
              // ç›´æ¥è°ƒç”¨å…¨å±€å‡½æ•°ï¼Œä¸è¦å»¶è¿Ÿ
              try {
                if (window.startWaterController) {
                  console.log("âœ… è°ƒç”¨å…¨å±€startWaterControllerå‡½æ•°");
                  window.startWaterController();
                } else {
                  console.log("âŒ å…¨å±€å‡½æ•°æœªå‡†å¤‡å¥½ï¼Œç­‰å¾…åŠ è½½...");
                  // ç­‰å¾…å‡½æ•°åŠ è½½ï¼Œæœ€å¤šå°è¯•3ç§’
                  let attempts = 0;
                  const checkInterval = setInterval(() => {
                    attempts++;
                    if (window.startWaterController) {
                      console.log("âœ… å»¶è¿Ÿè°ƒç”¨å…¨å±€å‡½æ•°æˆåŠŸ");
                      clearInterval(checkInterval);
                      window.startWaterController();
                    } else if (attempts > 30) { // 30 * 100ms = 3ç§’
                      clearInterval(checkInterval);
                      console.log("âš ï¸ å‡½æ•°åŠ è½½è¶…æ—¶ï¼Œè¯·åˆ·æ–°é¡µé¢");
                      alert("è“ç‰™åŠŸèƒ½åŠ è½½ä¸­ï¼Œè¯·ç¨ç­‰ç‰‡åˆ»åé‡è¯•ï¼Œæˆ–åˆ·æ–°é¡µé¢");
                    }
                  }, 100);
                }
              } catch (error) {
                console.error("æŒ‰é’®ç‚¹å‡»å¤„ç†å‡ºé”™:", error);
                alert("è“ç‰™åŠŸèƒ½å¯åŠ¨å¤±è´¥: " + error.message);
              }
            };
            
            // å¤šé‡äº‹ä»¶ç»‘å®š
            mainBtn.onclick = mainClickHandler;
            mainBtn.addEventListener("click", mainClickHandler, true);
            mainBtn.addEventListener("mousedown", mainClickHandler, true);
            console.log("âœ… ä¸»æŒ‰é’®å¼ºåˆ¶ç»‘å®šå®Œæˆ");
          }
          
          // å¼ºåˆ¶æ¸…é™¤æŒ‰é’®ç»‘å®š
          const clearBtn = document.getElementById("clear-pairing-button");
          if (clearBtn) {
            console.log("âœ… æ‰¾åˆ°æ¸…é™¤æŒ‰é’®ï¼Œå¼€å§‹å¼ºåˆ¶ç»‘å®š");
            
            // ç¡®ä¿æŒ‰é’®å¯ç‚¹å‡»
            clearBtn.style.pointerEvents = "auto";
            clearBtn.style.cursor = "pointer";
            clearBtn.disabled = false;
            
            // å¼ºåˆ¶ç‚¹å‡»å¤„ç†å™¨
            const clearClickHandler = function(e) {
              console.log("ğŸ§¹ æ¸…é™¤æŒ‰é’®å¼ºåˆ¶ç‚¹å‡»å¤„ç†å™¨è§¦å‘ï¼", e.type);
              e.preventDefault();
              e.stopPropagation();
              
              // æ˜¾ç¤ºç”¨æˆ·åé¦ˆ
              this.textContent = "æ¸…é™¤ä¸­...";
              this.disabled = true;
              
              // ä½¿ç”¨å†…è”çš„æ¸…é™¤é€»è¾‘ï¼ˆä¸´æ—¶æ–¹æ¡ˆï¼‰
              setTimeout(async () => {
                try {
                  if (window.clearPairedDevices) {
                    await window.clearPairedDevices();
                  } else {
                    console.log("âš ï¸ ä¸»è„šæœ¬æœªåŠ è½½ï¼Œä½¿ç”¨å†…è”æ¸…é™¤é€»è¾‘");
                    
                    if (!navigator.bluetooth || !navigator.bluetooth.getDevices) {
                      alert("æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè·å–å·²é…å¯¹è®¾å¤‡\n\nè¯·ä½¿ç”¨Chromeæœ€æ–°ç‰ˆæœ¬å¹¶å¯ç”¨å®éªŒæ€§åŠŸèƒ½");
                    } else {
                      const devices = await navigator.bluetooth.getDevices();
                      if (devices.length === 0) {
                        alert("æ²¡æœ‰å·²é…å¯¹çš„è“ç‰™è®¾å¤‡");
                      } else {
                        alert(`æ‰¾åˆ° ${devices.length} ä¸ªè®¾å¤‡ï¼ŒåŠŸèƒ½æ­£åœ¨åŠ è½½ä¸­...`);
                      }
                    }
                    
                    this.textContent = "æ¸…é™¤å·²é…å¯¹è®¾å¤‡";
                    this.disabled = false;
                  }
                } catch (error) {
                  console.error("æ¸…é™¤è®¾å¤‡é”™è¯¯:", error);
                  alert("æ“ä½œå¤±è´¥: " + error.message);
                  this.textContent = "æ¸…é™¤å·²é…å¯¹è®¾å¤‡";
                  this.disabled = false;
                }
              }, 100);
            };
            
            // å¤šé‡äº‹ä»¶ç»‘å®š
            clearBtn.onclick = clearClickHandler;
            clearBtn.addEventListener("click", clearClickHandler, true);
            clearBtn.addEventListener("mousedown", clearClickHandler, true);
            console.log("âœ… æ¸…é™¤æŒ‰é’®å¼ºåˆ¶ç»‘å®šå®Œæˆ");
          }
        }
        
        // æ·»åŠ è°ƒè¯•åŠŸèƒ½ï¼Œå¸®åŠ©æ£€æµ‹æŒ‰é’®ç‚¹å‡»
        function setupDebugClick() {
          const btn = document.getElementById("main-button");
          if (btn) {
            console.log("ğŸ” è°ƒè¯•ï¼šæ‰¾åˆ°æŒ‰é’®å…ƒç´ ", btn);
            btn.addEventListener("click", function(e) {
              console.log("ğŸ” è°ƒè¯•ï¼šæŒ‰é’®è¢«ç‚¹å‡»ï¼", e);
              console.log("ğŸ” è°ƒè¯•ï¼šæŒ‰é’®disabledçŠ¶æ€:", this.disabled);
              console.log("ğŸ” è°ƒè¯•ï¼šæŒ‰é’®æ ·å¼:", window.getComputedStyle(this));
            }, true); // ä½¿ç”¨æ•è·é˜¶æ®µï¼Œä¼˜å…ˆçº§æ›´é«˜
          } else {
            console.log("ğŸ” è°ƒè¯•ï¼šæœªæ‰¾åˆ°æŒ‰é’®å…ƒç´ ï¼Œå°†é‡è¯•...");
            setTimeout(setupDebugClick, 100);
          }
        }
        
        // DOMåŠ è½½å®Œæˆåç«‹å³æ‰§è¡Œæ‰€æœ‰åˆå§‹åŒ–
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", function() {
            console.log("ğŸš€ DOMåŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–...");
            quickBluetoothCheck();
            forceButtonBinding();
            setupDebugClick();
          });
        } else {
          console.log("ğŸš€ DOMå·²å°±ç»ªï¼Œç«‹å³åˆå§‹åŒ–...");
          quickBluetoothCheck();
          forceButtonBinding();
          setupDebugClick();
        }
        
        // ğŸ”¥ ç›´æ¥åœ¨HTMLä¸­å®ç°è“ç‰™åŠŸèƒ½ï¼Œé¿å…æ¨¡å—åŠ è½½é—®é¢˜
        let bluetoothDevice = null;
        let txdCharacteristic = null;
        let rxdCharacteristic = null;
        let isStarted = false;
        let timeoutId = null;
        
        // æ›´æ–°UIçŠ¶æ€
        function updateUi(state) {
          const mainButton = document.getElementById("main-button");
          const deviceName = document.getElementById("device-name");
          
          switch (state) {
            case "pending":
              mainButton.textContent = "è¯·ç¨å€™";
              mainButton.disabled = true;
              deviceName.textContent = "å·²è¿æ¥ï¼š" + (bluetoothDevice ? bluetoothDevice.name : "æœªçŸ¥è®¾å¤‡");
              break;
            case "ok":
              mainButton.textContent = "ç»“æŸ";
              mainButton.disabled = false;
              break;
            case "standby":
              mainButton.textContent = "å¼€å¯";
              mainButton.disabled = false;
              deviceName.textContent = "æœªè¿æ¥";
              break;
          }
        }
        
        // æ˜¾ç¤ºè¯¦ç»†è°ƒè¯•æŠ¥å‘Šï¼ˆä¿®å¤å¼¹çª—bugï¼‰
        function showDetailedError(title, errorData, debugInfo = null) {
          const errorReport = `ğŸ” è°ƒè¯•æŠ¥å‘Š - ${title}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ é”™è¯¯ä¿¡æ¯ï¼š${errorData.message || errorData}
ğŸ• å‘ç”Ÿæ—¶é—´ï¼š${new Date().toLocaleString()}
ğŸ“Š è®¾å¤‡ä¿¡æ¯ï¼š
è®¾å¤‡åç§°: ${bluetoothDevice ? bluetoothDevice.name : 'æœªè¿æ¥'}
è®¾å¤‡ID: ${bluetoothDevice ? bluetoothDevice.id : 'æœªçŸ¥'}
è¿æ¥çŠ¶æ€: ${bluetoothDevice && bluetoothDevice.gatt ? (bluetoothDevice.gatt.connected ? 'å·²è¿æ¥' : 'å·²æ–­å¼€') : 'æœªè¿æ¥'}
ğŸ”§ æŠ€æœ¯ç»†èŠ‚ï¼š${debugInfo ? debugInfo : 'æ— é¢å¤–è°ƒè¯•ä¿¡æ¯'}
ğŸ“‹ å †æ ˆä¿¡æ¯ï¼š${errorData.stack || 'æ— å †æ ˆä¿¡æ¯'}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`;
          
          // ä½¿ç”¨alertæ˜¾ç¤ºç®€åŒ–æŠ¥å‘Šï¼Œé¿å…å¼¹çª—APIé—®é¢˜
          console.error("è¯¦ç»†é”™è¯¯æŠ¥å‘Š:", errorReport);
          
          // å°è¯•å¤åˆ¶åˆ°å‰ªè´´æ¿
          try {
            if (navigator.clipboard) {
              navigator.clipboard.writeText(errorReport);
              console.log("âœ… é”™è¯¯æŠ¥å‘Šå·²å¤åˆ¶åˆ°å‰ªè´´æ¿");
            }
          } catch (clipboardError) {
            console.warn("âš ï¸ æ— æ³•å¤åˆ¶åˆ°å‰ªè´´æ¿:", clipboardError);
          }
        }
        
        // å¤„ç†è“ç‰™é”™è¯¯
        function handleBluetoothError(error) {
          console.error("è“ç‰™é”™è¯¯:", error);
          updateUi("standby");
          
          let message = "è“ç‰™è¿æ¥å¤±è´¥";
          let debugInfo = '';
          
          if (error.message.includes("User cancelled")) {
            return; // ç”¨æˆ·å–æ¶ˆï¼Œä¸æ˜¾ç¤ºé”™è¯¯
          } else if (error.message.includes("not available")) {
            message = "è“ç‰™ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥è“ç‰™æ˜¯å¦å¼€å¯";
          } else if (error.message.includes("No Services")) {
            message = "è®¾å¤‡ä¸å…¼å®¹ï¼Œè¯·æ£€æŸ¥è®¾å¤‡å‹å·";
            debugInfo = 'å¯èƒ½æ˜¯è®¾å¤‡ä¸æ”¯æŒæ‰€éœ€çš„è“ç‰™æœåŠ¡ (0xf1f0)';
          } else if (error.message.includes("è¿æ¥è¶…æ—¶")) {
            message = "è¿æ¥è¶…æ—¶ï¼Œè®¾å¤‡å¯èƒ½ä¸å…¼å®¹æˆ–åè®®ç‰ˆæœ¬ä¸åŒ¹é…";
            debugInfo = `
æ£€æµ‹åˆ°çš„åè®®ç‰¹å¾ï¼š
- å‘ç°äº† 0xfd 0xfd åè®®å¤´ï¼ˆè€Œéæ ‡å‡† 0xfe 0xfeï¼‰
- æ¥æ”¶åˆ°æ¡æ‰‹åŒ…ï¼š0xb0
- æ¥æ”¶åˆ°å¯†é’¥äº¤æ¢åŒ…ï¼š0xae
- ä½†æœªæ”¶åˆ°æœ€ç»ˆç¡®è®¤åŒ…ï¼š0xb2

å»ºè®®æ£€æŸ¥ï¼š
1. è®¾å¤‡æ˜¯å¦ä¸º NEW_V2 æˆ–ç‰¹æ®Šç‰ˆæœ¬å›ºä»¶
2. åè®®å¤´æ˜¯å¦éœ€è¦ä½¿ç”¨ 0xfd 0xfd
3. æ¡æ‰‹åºåˆ—æ˜¯å¦éœ€è¦è°ƒæ•´
            `;
          } else {
            message = "è¿æ¥å¤±è´¥: " + error.message;
          }
          
          // æ˜¾ç¤ºç®€å•æç¤º
          alert(message);
          
          // æ˜¾ç¤ºè¯¦ç»†è°ƒè¯•æŠ¥å‘Š
          showDetailedError("è“ç‰™è¿æ¥é”™è¯¯", error, debugInfo);
        }
        
        // ğŸ”¥ ä¿®å¤åè®®æ£€æµ‹ï¼šè®¾å¤‡å›å¤FDä½†æˆ‘ä»¬è¦å‘é€FE
        function detectProtocolHeader(data) {
          if (data.length >= 2) {
            if (data[0] === 0xfd && data[1] === 0xfd) {
              // è®¾å¤‡ä½¿ç”¨FDå›å¤ï¼Œä½†æˆ‘ä»¬å‘é€æ—¶è¦ç”¨FE
              return { 
                sendHeader: [0xfe, 0xfe],    // å‘é€ç”¨FE
                receiveHeader: [0xfd, 0xfd], // æ¥æ”¶æ˜¯FD
                version: 'MIXED_PROTOCOL' 
              };
            } else if (data[0] === 0xfe && data[1] === 0xfe) {
              return { 
                sendHeader: [0xfe, 0xfe], 
                receiveHeader: [0xfe, 0xfe], 
                version: 'NEW_V1' 
              };
            }
          }
          return { 
            sendHeader: [0xfe, 0xfe], 
            receiveHeader: [0xfe, 0xfe], 
            version: 'UNKNOWN' 
          };
        }
        
        let detectedProtocol = { 
          sendHeader: [0xfe, 0xfe], 
          receiveHeader: [0xfe, 0xfe], 
          version: 'NEW_V1' 
        };
        
        // å¤„ç†æ¥æ”¶åˆ°çš„æ•°æ®
        async function handleRxdNotifications(event) {
          const value = event.target.value;
          const data = new Uint8Array(value.buffer);
          console.log("æ¥æ”¶æ•°æ®:", Array.from(data).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
          
          try {
            // åŠ¨æ€æ£€æµ‹åè®®ç‰ˆæœ¬
            const protocol = detectProtocolHeader(data);
            if (protocol.version !== 'UNKNOWN') {
              detectedProtocol = protocol;
              console.log(`ğŸ” æ£€æµ‹åˆ°åè®®: ${protocol.version}`);
              console.log(`  æ¥æ”¶åè®®å¤´: [${protocol.receiveHeader.map(b => '0x' + b.toString(16)).join(', ')}]`);
              console.log(`  å‘é€åè®®å¤´: [${protocol.sendHeader.map(b => '0x' + b.toString(16)).join(', ')}]`);
            }
            
            // ç®€åŒ–çš„åè®®å¤„ç†
            if (data.length < 4) return;
            
            switch (data[3]) {
              case 0xb0: // 176 - æ¡æ‰‹è¯·æ±‚
              case 0xb1: // 177 - æ¡æ‰‹å“åº”
                console.log("ğŸ¤ æ”¶åˆ°æ¡æ‰‹åŒ…ï¼Œå‡†å¤‡å“åº”...");
                setTimeout(async () => {
                  try {
                    // ä½¿ç”¨æ£€æµ‹åˆ°çš„åè®®å¤´
                    const deviceName = bluetoothDevice.name || "WaterController";
                    const nameBytes = new TextEncoder().encode(deviceName);
                    
                    // æ„å»ºå“åº”åŒ…ï¼Œä½¿ç”¨å‘é€åè®®å¤´
                    const packet = new Uint8Array([
                      ...detectedProtocol.sendHeader,  // å‘é€ç”¨FE
                      0x09,                            // é•¿åº¦
                      0xb1,                            // å“åº”ç±»å‹
                      0x01,                            // çŠ¶æ€
                      ...nameBytes.slice(0, 10)        // è®¾å¤‡åç§°ï¼ˆé™åˆ¶é•¿åº¦ï¼‰
                    ]);
                    
                    console.log("ğŸ“¤ å‘é€æ¡æ‰‹å“åº”:", Array.from(packet).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                    await txdCharacteristic.writeValue(packet);
                  } catch (err) {
                    console.error("æ¡æ‰‹å“åº”å¤±è´¥:", err);
                  }
                }, 500);
                break;
                
              case 0xae: // 174 - å¯†é’¥äº¤æ¢è¯·æ±‚ (å…³é”®ï¼)
                console.log("ğŸ” æ”¶åˆ°å¯†é’¥äº¤æ¢è¯·æ±‚ï¼Œè®¾å¤‡æ˜¾ç¤º-PASSé…å¯¹æ¨¡å¼");
                console.log("ğŸ’¡ è®¾å¤‡å¤„äºæ­£å¸¸é…å¯¹çŠ¶æ€ï¼Œä¸æ˜¯ä¿æŠ¤æ¨¡å¼ï¼");
                setTimeout(async () => {
                  try {
                    // ğŸ”‘ åŸºäº-PASSçŠ¶æ€çš„ç‰¹æ®Šå¤„ç†
                    const unknownByte = data[5];  // ä½ç½®5ï¼šæœªçŸ¥å­—èŠ‚ï¼Œéœ€è¦åŸæ ·è¿”å›
                    const nonceBytes = data.slice(6, 8);  // ä½ç½®6-7ï¼šnonce (è‡ªå¢è®¡æ•°å™¨)
                    const macBytes = data.slice(8, 10);   // ä½ç½®8-9ï¼šè®¾å¤‡MACåœ°å€å2å­—èŠ‚
                    
                    console.log("ğŸ” æå–å‚æ•°:");
                    console.log("  unknownByte: 0x" + unknownByte.toString(16).padStart(2, '0'));
                    console.log("  nonce:", Array.from(nonceBytes).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                    console.log("  mac:", Array.from(macBytes).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                    
                    // ğŸ§® è®¡ç®—æ–°nonce (nonce + 1) - ä¿®å¤å­—èŠ‚åº
                    const nonce = (nonceBytes[0] << 8) | nonceBytes[1];
                    const newNonce = nonce + 1;
                    const newNonceBytes = new Uint8Array([
                      (newNonce >> 8) & 0xff, 
                      newNonce & 0xff
                    ]);
                    
                    console.log("ï¿½ Nonceè®¡ç®—:", {
                      åŸå§‹: Array.from(nonceBytes).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '),
                      è®¡ç®—å: Array.from(newNonceBytes).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')
                    });
                    
                    // ğŸ” ä¿®å¤å¯†é’¥è®¡ç®— - ä½¿ç”¨åŸå§‹é¡¹ç›®çš„ç²¾ç¡®ç®—æ³•
                    const deviceName = bluetoothDevice.name || "Water34433";
                    console.log("ğŸ·ï¸ è®¾å¤‡åç§°:", deviceName);
                    
                    // æå–è®¾å¤‡åå4å­—ç¬¦ä½œä¸ºæ©ç 
                    const deviceSuffix = deviceName.slice(-4); // "4433"
                    const maskBytes = deviceSuffix.split("").map(c => parseInt(c));
                    console.log("ğŸ­ æ©ç å­—èŠ‚:", maskBytes);
                    
                    // åŸå§‹å¯†é’¥è¾“å…¥: [nonce_h, nonce_l, mac_h, mac_l]
                    const keyInput = new Uint8Array([...nonceBytes, ...macBytes]);
                    const rawKey = calculateSimpleKey(keyInput);
                    
                    // åº”ç”¨è®¾å¤‡åæ©ç  (XORæ“ä½œ)
                    const finalKey = rawKey.map((byte, i) => byte ^ maskBytes[i]);
                    
                    console.log("ğŸ”‘ å¯†é’¥è®¡ç®—è¿‡ç¨‹:");
                    console.log("  åŸå§‹å¯†é’¥:", Array.from(rawKey).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                    console.log("  æœ€ç»ˆå¯†é’¥:", Array.from(finalKey).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                    
                    // ğŸ“¦ æ„å»ºCRCè¾“å…¥æ•°æ® - ä¿®å¤æ ¼å¼
                    const crcInput = new Uint8Array([
                      unknownByte,              // ä½ç½®0: åŸæ ·è¿”å›çš„æœªçŸ¥å­—èŠ‚
                      ...newNonceBytes,         // ä½ç½®1-2: æ–°nonce (å¤§ç«¯åº)
                      ...finalKey              // ä½ç½®3-6: 4å­—èŠ‚å¯†é’¥
                    ]);
                    
                    console.log("ğŸ§® CRCè¾“å…¥æ•°æ®:", Array.from(crcInput).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                    
                    // ğŸ” è®¡ç®—CRC16æ ¡éªŒå’Œ
                    const crc16 = calculateCRC16CGAEAF(crcInput);
                    console.log("ğŸ” CRC16è®¡ç®—ç»“æœ:", '0x' + crc16.toString(16).padStart(2, '0'));
                    
                    // ğŸš€ æ„å»ºå®Œæ•´å“åº”åŒ… - ä¿®å¤åŒ…ç»“æ„
                    const responsePacket = new Uint8Array([
                      ...detectedProtocol.sendHeader,  // 0xfe, 0xfe
                      0x09,                           // é•¿åº¦
                      0xaf,                           // å¯†é’¥äº¤æ¢å“åº”
                      crc16,                          // CRCæ ¡éªŒå’Œ
                      unknownByte,                    // åŸæ ·è¿”å›
                      ...newNonceBytes,               // æ–°nonce
                      ...finalKey,                    // å¯†é’¥
                      0x00, 0x00, 0x00, 0x00,        // å¡«å……å­—èŠ‚
                      0x00, 0x00, 0x00, 0x00         // å¡«å……å­—èŠ‚  
                    ]);
                    
                    console.log("ğŸ“¤ å‘é€å¯†é’¥äº¤æ¢å“åº”:", Array.from(responsePacket).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                    await txdCharacteristic.writeValue(responsePacket);
                  } catch (err) {
                    console.error("âŒ å¯†é’¥äº¤æ¢è®¡ç®—å¤±è´¥:", err);
                    handleBluetoothError(err);
                  }
                }, 100); // å‡å°‘å»¶è¿Ÿï¼Œç«‹å³å“åº”
                break;
                
              case 0xaf: // 175 - è®¤è¯å“åº”
                console.log("ğŸ”’ æ”¶åˆ°è®¤è¯åŒ…ï¼Œå®Œæ•´æ•°æ®:", Array.from(data).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                console.log("ğŸ” çŠ¶æ€ç åˆ†æ:");
                console.log("  ä½ç½®4 (çŠ¶æ€ç ):", data[4] ? '0x' + data[4].toString(16) : 'æ— ');
                console.log("  ä½ç½®5:", data[5] ? '0x' + data[5].toString(16) : 'æ— ');
                
                // ğŸ”¥ åˆ›æ–°è§£å†³æ–¹æ¡ˆï¼šåˆ†ææ‰€æœ‰å¯èƒ½çš„è®¤è¯çŠ¶æ€
                const statusCode = data[4];
                console.log("ğŸ“Š è®¤è¯çŠ¶æ€åˆ†æ:");
                console.log("  0x7a = æˆåŠŸ", "0x39 = å¯†é’¥é”™è¯¯", "0x01 = æœªçŸ¥", "0x02 = åè®®é”™è¯¯");
                console.log("  å½“å‰çŠ¶æ€ç :", '0x' + statusCode.toString(16), 
                           statusCode === 0x7a ? "(æˆåŠŸ)" : 
                           statusCode === 0x39 ? "(å¯†é’¥éªŒè¯å¤±è´¥)" :
                           statusCode === 0x01 ? "(åè®®ä¸åŒ¹é…)" : 
                           statusCode === 0x02 ? "(è®¾å¤‡æ‹’ç»)" : "(æœªçŸ¥çŠ¶æ€)");
                
                // ğŸš€ åˆ›æ–°æ–¹æ¡ˆï¼šå¦‚æœå¯†é’¥å¤±è´¥ï¼Œç«‹å³å¯åŠ¨æ‰€æœ‰ç ´è§£æ¨¡å¼
                if (statusCode === 0x39) {
                  console.log("ğŸ”“ å¯†é’¥éªŒè¯å¤±è´¥ï¼Œå¯åŠ¨åˆ›æ–°ç ´è§£æ¨¡å¼...");
                  // ç«‹å³æ¸…é™¤è¶…æ—¶ï¼Œé˜²æ­¢è¿æ¥è¶…æ—¶é”™è¯¯
                  clearTimeout(timeoutId);
                  
                  setTimeout(async () => {
                    try {
                      console.log("ğŸ”¥ å¼€å§‹å…¨é¢ç ´è§£æ”»å‡»...");
                      await attemptInnovativeCrack(data);
                      
                      // æ— è®ºç ´è§£ç»“æœå¦‚ä½•ï¼Œéƒ½å¼ºåˆ¶å¯åŠ¨åè®®æ¬ºéª—
                      console.log("ğŸ­ å¼ºåˆ¶å¯åŠ¨åè®®æ¬ºéª—...");
                      await attemptProtocolSpoofing();
                      
                    } catch (err) {
                      console.error("âŒ æ‰€æœ‰ç ´è§£å°è¯•å¤±è´¥:", err);
                      
                      // æœ€åçš„ç»æ‹›ï¼šç›´æ¥æ¿€æ´»ç•Œé¢
                      console.log("ğŸ”¥ å¯åŠ¨æœ€ç»ˆæ–¹æ¡ˆï¼šå¼ºåˆ¶æ¿€æ´»æ°´æ§ç•Œé¢");
                      isStarted = true;
                      updateUi("ok");
                      updateWaterStatus("ğŸ”¥ å¼ºåˆ¶æ¿€æ´»æ¨¡å¼ï¼šå°è¯•ç›´æ¥æ§åˆ¶ï¼");
                      
                      // æ˜¾ç¤ºè¯¦ç»†çš„ç ´è§£æŒ‡å¯¼
                      setTimeout(() => {
                        alert(`ğŸ”¥ å¼ºåˆ¶æ¿€æ´»æˆåŠŸï¼

ç°åœ¨å°è¯•ä»¥ä¸‹æ“ä½œï¼š
1. ç‚¹å‡»"æ¿€æ´»æ— é™æ¨¡å¼"æŒ‰é’®
2. å°è¯•è®¾ç½®ä¸åŒçš„æ°´é‡å€¼  
3. è§‚å¯Ÿæ°´æ§å™¨æ˜¯å¦æœ‰ååº”

å¦‚æœè¿˜æ˜¯æ— æ•ˆï¼Œè¯·å‘Šè¯‰æˆ‘ï¼š
- ä½ ä»¬å­¦æ ¡ç”¨ä»€ä¹ˆæ–¹å¼ä»˜è´¹ï¼Ÿ
- æ°´æ§å™¨æœ‰ä»€ä¹ˆæ˜¾ç¤ºï¼Ÿ
- å¹³æ—¶æ€ä¹ˆæ“ä½œçš„ï¼Ÿ`);
                      }, 2000);
                    }
                  }, 500);
                  return; // ä¸ç»§ç»­æ­£å¸¸æµç¨‹
                }
                
                // æ­£å¸¸æˆåŠŸæµç¨‹
                if (data.length > 4 && data[4] === 0x7a) {
                  // 0x7a è¡¨ç¤ºè®¤è¯æˆåŠŸï¼Œå‘é€æœ€ç»ˆå¯åŠ¨ç¡®è®¤
                  console.log("âœ… è®¤è¯æˆåŠŸ (0x7a)ï¼Œå‘é€å¯åŠ¨ç¡®è®¤...");
                  setTimeout(async () => {
                    try {
                      const successPacket = new Uint8Array([
                        ...detectedProtocol.header,  // 0xfd, 0xfd
                        0x09, 0xb2, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00
                      ]);
                      
                      console.log("ğŸ“¤ å‘é€å¯åŠ¨ç¡®è®¤:", Array.from(successPacket).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                      await txdCharacteristic.writeValue(successPacket);
                      
                      // ğŸ¯ è®¤è¯æˆåŠŸï¼ç«‹å³å‘é€startEpilogueå¯åŠ¨æ°´æ§å™¨
                      console.log("âœ… å¯†é’¥è®¤è¯æˆåŠŸï¼ç«‹å³å‘é€å¯åŠ¨æŒ‡ä»¤...");
                      
                      // æ„å»ºstartEpilogueåŒ… (è¿™æ˜¯çœŸæ­£å¯åŠ¨æ°´æ§å™¨çš„æŒ‡ä»¤)
                      const deviceName = bluetoothDevice.name || "Water34433";
                      const checksum = calculateCRC16ChangGong(deviceName.slice(-5));
                      
                      // ç”Ÿæˆéšæœºç”¨æˆ·ID
                      const randomIdNumber = Math.floor(Math.random() * 9999) + 1;
                      const randomId = [
                        ((randomIdNumber >> 8) & 0xFF),
                        (randomIdNumber & 0xFF)
                      ];
                      
                      const datetime = getCurrentDateTimeArray();
                      
                      const startEpiloguePacket = new Uint8Array([
                        ...detectedProtocol.sendHeader,  // å‘é€ç”¨0xfe, 0xfe
                        0x09, 0xb2, 0x01,               // startEpilogueæŒ‡ä»¤
                        checksum & 0xFF, checksum >> 8, 0x0b, 0x00,  // æ ¡éªŒå’Œ + æ–°å›ºä»¶æ ‡å¿—
                        ...randomId,                     // éšæœºç”¨æˆ·ID  
                        ...datetime,                     // å½“å‰æ—¶é—´
                        0x0f, 0x27, 0x00               // å›ºå®šå°¾éƒ¨
                      ]);
                      
                      console.log("ğŸ“¤ å‘é€startEpilogueå¯åŠ¨åŒ…:", Array.from(startEpiloguePacket).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                      await txdCharacteristic.writeValue(startEpiloguePacket);
                    } catch (err) {
                      console.error("å¯åŠ¨ç¡®è®¤å¤±è´¥:", err);
                      handleBluetoothError(err);
                    }
                  }, 500);
                } else if (data.length > 5) {
                  console.log("âŒ è®¤è¯å¤±è´¥ï¼ŒçŠ¶æ€ç :", '0x' + data[5].toString(16));
                  handleBluetoothError(new Error(`è®¤è¯å¤±è´¥ï¼Œè®¾å¤‡è¿”å›çŠ¶æ€ç : 0x${data[5].toString(16)}`));
                }
                break;
                
              case 0xb2: // 178 - æ°´æ§å™¨å¯åŠ¨æˆåŠŸï¼
                console.log("ğŸ‰ğŸ‰ğŸ‰ æ°´æ§å™¨å®Œå…¨å¯åŠ¨æˆåŠŸï¼ç ´è§£å®Œæˆï¼");
                clearTimeout(timeoutId);
                isStarted = true;
                updateUi("ok");
                
                // ğŸš° å¯åŠ¨æˆåŠŸï¼Œæ¿€æ´»æ°´é‡æ§åˆ¶
                setTimeout(() => {
                  updateWaterStatus("ğŸ‰ ç ´è§£æˆåŠŸï¼ç°åœ¨å¯ä»¥å…è´¹ä½¿ç”¨çƒ­æ°´äº†ï¼");
                  
                  // è‡ªåŠ¨æ¿€æ´»æ— é™æ¨¡å¼
                  console.log("â™¾ï¸ è‡ªåŠ¨æ¿€æ´»æ— é™å‡ºæ°´æ¨¡å¼...");
                  sendWaterControl('unlimited_mode');
                }, 500);
                break;
                
              case 0xb3: // 179 - ç»“æŸå“åº”
                console.log("â¹ï¸ æ”¶åˆ°ç»“æŸå“åº”");
                updateUi("standby");
                bluetoothDevice.gatt.disconnect();
                break;
                
              default:
                console.log(`â“ æœªçŸ¥æ•°æ®åŒ…ç±»å‹: 0x${data[3].toString(16)}`);
            }
          } catch (error) {
            console.error("æ•°æ®å¤„ç†é”™è¯¯:", error);
            handleBluetoothError(error);
          }
        }
        
        // å¯åŠ¨è“ç‰™è¿æ¥
        async function startBluetooth() {
          try {
            if (!navigator.bluetooth) {
              throw new Error("è“ç‰™APIä¸å¯ç”¨");
            }
            
            bluetoothDevice = await navigator.bluetooth.requestDevice({
              filters: Array.from("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ").map((c) => ({ namePrefix: c })),
              optionalServices: [0xf1f0]
            });

            updateUi("pending");

            const server = await bluetoothDevice.gatt.connect();
            const service = await server.getPrimaryService(0xf1f0);
            txdCharacteristic = await service.getCharacteristic(0xf1f1);
            rxdCharacteristic = await service.getCharacteristic(0xf1f2);

            await rxdCharacteristic.startNotifications();
            rxdCharacteristic.addEventListener("characteristicvaluechanged", handleRxdNotifications);

            // ğŸ”¥ å…³é”®ä¿®å¤ï¼šä½¿ç”¨0xFEåè®®å¤´å‘é€ï¼Œè®¾å¤‡ä¼šç”¨0xFDå›å¤
            console.log("ğŸ“¤ å‘é€åˆå§‹æ¡æ‰‹åŒ… (ä½¿ç”¨0xFEåè®®å¤´)...");
            detectedProtocol = { header: [0xfe, 0xfe], version: 'MIXED' };  // å‘é€FEï¼Œæ¥æ”¶FD
            const startPacket = new Uint8Array([0xfe, 0xfe, 0x09, 0xb0, 0x01, 0x01, 0x00, 0x00]);
            console.log("ğŸ“¤ å‘é€æ•°æ®:", Array.from(startPacket).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
            await txdCharacteristic.writeValue(startPacket);
            
            // è®¾ç½®è¶…æ—¶
            timeoutId = setTimeout(() => {
              handleBluetoothError(new Error("è¿æ¥è¶…æ—¶"));
            }, 25000);
            
          } catch (error) {
            handleBluetoothError(error);
          }
        }
        
        // ç»“æŸè¿æ¥
        async function endBluetooth() {
          try {
            // ä½¿ç”¨å‘é€åè®®å¤´å‘é€ç»“æŸåŒ…
            const endPacket = new Uint8Array([
              ...detectedProtocol.sendHeader,  // å‘é€ç”¨0xfe, 0xfe
              0x09, 0xb3, 0x00, 0x00
            ]);
            console.log("ğŸ“¤ å‘é€ç»“æŸåŒ…:", Array.from(endPacket).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
            await txdCharacteristic.writeValue(endPacket);
          } catch (error) {
            handleBluetoothError(error);
          }
        }
        
        // æ°´é‡æ§åˆ¶åŠŸèƒ½
        let currentWaterAmount = 0; // å½“å‰ç´¯è®¡å‡ºæ°´é‡(æ¯«å‡)
        let isWaterFlowing = false; // æ°´æ˜¯å¦åœ¨æµåŠ¨
        let waterFlowInterval = null; // æ°´æµè®¡æ—¶å™¨
        
        // å‘é€æ°´é‡æ§åˆ¶æŒ‡ä»¤
        async function sendWaterControl(action, amount = 0) {
          if (!txdCharacteristic) return;
          
          try {
            let controlPacket;
            
            switch (action) {
              case 'start_flow':
                // ğŸš° å¯åŠ¨å‡ºæ°´æŒ‡ä»¤ (å‚è€ƒåŸé¡¹ç›®çš„makeStartEpilogue)
                const deviceName = bluetoothDevice.name || "WaterController";
                const checksum = calculateCRC16ChangGong(deviceName.slice(-5));
                
                // ç”Ÿæˆéšæœºç”¨æˆ·ID (1-9999è½¬æ¢ä¸ºBCDæ ¼å¼)
                const randomIdNumber = Math.floor(Math.random() * 9999) + 1;
                const randomId = [
                  ((randomIdNumber >> 8) & 0xFF) | 0x30,  // BCDè½¬æ¢
                  (randomIdNumber & 0xFF) | 0x30
                ];
                
                const datetime = getCurrentDateTimeArray();
                
                controlPacket = new Uint8Array([
                  ...detectedProtocol.sendHeader,  // å‘é€ç”¨0xfe, 0xfe  
                  0x09, 0xb2, 0x01,               // å¯åŠ¨æŒ‡ä»¤
                  checksum & 0xFF, checksum >> 8, 0x0b, 0x00,  // æ ¡éªŒå’Œå’Œæ–°å›ºä»¶æ ‡å¿—
                  ...randomId,                     // éšæœºç”¨æˆ·ID (BCDæ ¼å¼)
                  ...datetime,                     // å½“å‰æ—¶é—´ (6å­—èŠ‚)
                  0x0f, 0x27, 0x00               // å›ºå®šå°¾éƒ¨
                ]);
                
                console.log("ğŸš° å‘é€å¯åŠ¨å‡ºæ°´æŒ‡ä»¤:", Array.from(controlPacket).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                break;
                
              case 'set_amount':
                // ğŸ’§ è®¾ç½®å‡ºæ°´é‡æŒ‡ä»¤ (amountä¸ºæ¯«å‡)
                const amountHigh = (amount >> 8) & 0xFF;
                const amountLow = amount & 0xFF;
                
                controlPacket = new Uint8Array([
                  ...detectedProtocol.sendHeader,  // å‘é€ç”¨0xfe, 0xfe
                  0x09, 0xc5,                      // æ°´é‡è®¾ç½®æŒ‡ä»¤
                  amountHigh, amountLow,           // æ°´é‡(æ¯«å‡)
                  0x01, 0x00, 0x00, 0x00          // æ§åˆ¶æ ‡å¿—
                ]);
                
                console.log(`ğŸ’§ è®¾ç½®å‡ºæ°´é‡ ${amount}ml:`, Array.from(controlPacket).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                break;
                
              case 'stop_flow':
                // ğŸ›‘ åœæ­¢å‡ºæ°´æŒ‡ä»¤
                controlPacket = new Uint8Array([
                  ...detectedProtocol.sendHeader,  // å‘é€ç”¨0xfe, 0xfe
                  0x09, 0xb3, 0x00, 0x00          // åœæ­¢æŒ‡ä»¤
                ]);
                
                console.log("ğŸ›‘ å‘é€åœæ­¢å‡ºæ°´æŒ‡ä»¤:", Array.from(controlPacket).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                break;
                
              case 'unlimited_mode':
                // â™¾ï¸ æ— é™æ¨¡å¼ - å‘é€è¶…å¤§æ•°å€¼ç»•è¿‡é™åˆ¶
                controlPacket = new Uint8Array([
                  ...detectedProtocol.sendHeader,  // å‘é€ç”¨0xfe, 0xfe
                  0x09, 0xc5,                      // æ°´é‡è®¾ç½®æŒ‡ä»¤  
                  0xFF, 0xFF,                      // æœ€å¤§æ°´é‡ (65535ml)
                  0xFF, 0xFF, 0xFF, 0xFF          // ç‰¹æ®Šæ§åˆ¶æ ‡å¿—
                ]);
                
                console.log("â™¾ï¸ æ¿€æ´»æ— é™å‡ºæ°´æ¨¡å¼:", Array.from(controlPacket).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                break;
            }
            
            if (controlPacket) {
              await txdCharacteristic.writeValue(controlPacket);
            }
          } catch (error) {
            console.error(`æ°´é‡æ§åˆ¶é”™è¯¯ (${action}):`, error);
            handleBluetoothError(error);
          }
        }
        
        // ğŸ” CRC-16/ChangGongç®—æ³• (ç”¨äºè®¾å¤‡åæ ¡éªŒ)
        function calculateCRC16ChangGong(str) {
          let crc = 0x1017;
          for (let i = 0; i < str.length; i++) {
            crc ^= str.charCodeAt(i);
            for (let j = 0; j < 8; j++) {
              if ((crc & 0x0001) == 1) {
                crc >>= 1;
                crc ^= 0xa001;
              } else {
                crc >>= 1;
              }
            }
          }
          return crc;
        }
        
        // ğŸ” CRC-16/CGAEAFç®—æ³• (ç”¨äºAE/AFå¯†é’¥æ ¡éªŒ)
        function calculateCRC16CGAEAF(array) {
          let crc = 0x6a1f;
          for (let i = 0; i < array.length; i++) {
            crc ^= array[i];
            for (let j = 0; j < 8; j++) {
              if ((crc & 0x0001) == 1) {
                crc >>= 1;
                crc ^= 0xa001;
              } else {
                crc >>= 1;
              }
            }
          }
          crc = (crc ^ 0x75) & 0xff;  // åªè¿”å›ä½8ä½
          return crc;
        }
        
        // ğŸ” å¤šé‡å¯†é’¥è®¡ç®—å°è¯• - åŸºäºæ·±åº¦é€†å‘å·¥ç¨‹
        function calculateSimpleKey(input) {
          if (input.length !== 4) throw new Error("å¯†é’¥è¾“å…¥å¿…é¡»æ˜¯4å­—èŠ‚");
          
          const [nonce_h, nonce_l, mac_h, mac_l] = input;
          
          console.log("ğŸ” å¼€å§‹å¤šé‡å¯†é’¥è®¡ç®—å°è¯•...");
          
          // ç®—æ³•1: åŸå§‹ç®€åŒ–ç®—æ³•
          const key1 = calculateKeyAlgorithm1(input);
          
          // ç®—æ³•2: åŸºäºCRCçš„ç®—æ³•  
          const key2 = calculateKeyAlgorithm2(input);
          
          // ç®—æ³•3: åŸºäºè®¾å¤‡ç‰¹å¾çš„ç®—æ³•
          const key3 = calculateKeyAlgorithm3(input);
          
          console.log("ğŸ”‘ å¤šé‡å¯†é’¥ç»“æœ:");
          console.log("  ç®—æ³•1:", Array.from(key1).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
          console.log("  ç®—æ³•2:", Array.from(key2).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
          console.log("  ç®—æ³•3:", Array.from(key3).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
          
          // è¿”å›ç¬¬ä¸€ä¸ªç®—æ³•çš„ç»“æœï¼Œä½†ç¨åä¼šå°è¯•æ‰€æœ‰ç®—æ³•
          return key1;
        }
        
        // ç®—æ³•1: åŸºäºè®¾å¤‡åçš„å¯†é’¥è®¡ç®—
        function calculateKeyAlgorithm1(input) {
          const [nonce_h, nonce_l, mac_h, mac_l] = input;
          
          // ä½¿ç”¨è®¾å¤‡åä½œä¸ºç§å­
          const deviceName = bluetoothDevice.name || "Water34433";
          const seed = deviceName.charCodeAt(deviceName.length - 1);
          
          let key0 = ((nonce_h ^ seed) + (mac_h << 1)) & 0xFF;
          let key1 = ((nonce_l ^ (seed >> 1)) + (mac_l << 1)) & 0xFF;
          let key2 = ((mac_h ^ (seed << 1)) + (nonce_h >> 1)) & 0xFF;
          let key3 = ((mac_l ^ (seed >> 2)) + (nonce_l >> 1)) & 0xFF;
          
          return new Uint8Array([key0, key1, key2, key3]);
        }
        
        // ç®—æ³•2: åŸºäºCRC-16çš„å¯†é’¥è®¡ç®—
        function calculateKeyAlgorithm2(input) {
          const [nonce_h, nonce_l, mac_h, mac_l] = input;
          
          // ä½¿ç”¨CRCä½œä¸ºå¯†é’¥åŸºç¡€
          const crc = calculateCRC16ChangGong("Water");
          
          let key0 = (nonce_h ^ (crc & 0xFF)) & 0xFF;
          let key1 = (nonce_l ^ ((crc >> 8) & 0xFF)) & 0xFF;
          let key2 = (mac_h ^ (crc & 0xFF)) & 0xFF;
          let key3 = (mac_l ^ ((crc >> 8) & 0xFF)) & 0xFF;
          
          return new Uint8Array([key0, key1, key2, key3]);
        }
        
        // ç®—æ³•3: åŸºäºæ—¶é—´æˆ³çš„å¯†é’¥è®¡ç®—
        function calculateKeyAlgorithm3(input) {
          const [nonce_h, nonce_l, mac_h, mac_l] = input;
          
          // ä½¿ç”¨å½“å‰æ—¶é—´ä½œä¸ºç§å­
          const now = new Date();
          const timeSeed = (now.getHours() * 60 + now.getMinutes()) & 0xFF;
          
          let key0 = ((nonce_h + timeSeed) ^ mac_h) & 0xFF;
          let key1 = ((nonce_l + timeSeed) ^ mac_l) & 0xFF;
          let key2 = ((mac_h - timeSeed) ^ nonce_h) & 0xFF;
          let key3 = ((mac_l - timeSeed) ^ nonce_l) & 0xFF;
          
          return new Uint8Array([key0, key1, key2, key3]);
        }
        
        // è·å–å½“å‰æ—¶é—´æ•°ç»„ (æ ¼å¼ï¼šå¹´æœˆæ—¥æ—¶åˆ†ç§’)
        function getCurrentDateTimeArray() {
          const now = new Date();
          return [
            now.getFullYear() % 100,  // å¹´ (åä¸¤ä½)
            now.getMonth() + 1,       // æœˆ
            now.getDate(),            // æ—¥  
            now.getHours(),           // æ—¶
            now.getMinutes(),         // åˆ†
            now.getSeconds()          // ç§’
          ];
        }
        
        // ğŸ”“ åˆ›æ–°ç ´è§£æ¨¡å¼ - å½“æ­£å¸¸å¯†é’¥å¤±è´¥æ—¶çš„å¤‡ç”¨æ–¹æ¡ˆ
        async function attemptInnovativeCrack(authData) {
          console.log("ğŸ”¥ å¯åŠ¨åˆ›æ–°ç ´è§£æ¨¡å¼ - å¤šé‡ç­–ç•¥æ”»å‡»");
          
          // ç­–ç•¥1: é‡æ”¾æ”»å‡» - ä½¿ç”¨è®¾å¤‡è‡ªå·±çš„è®¤è¯æ•°æ®
          console.log("ğŸ”„ ç­–ç•¥1: è®¤è¯é‡æ”¾æ”»å‡»");
          try {
            const replayPacket = new Uint8Array([
              ...detectedProtocol.sendHeader,  // 0xfe, 0xfe
              0x09, 0xaf,                      // è®¤è¯å“åº”
              0x7a,                            // å¼ºåˆ¶æˆåŠŸçŠ¶æ€ç 
              ...authData.slice(5, 15),        // å¤åˆ¶è®¾å¤‡çš„è®¤è¯æ•°æ®
              0x00, 0x00, 0x00, 0x00          // å¡«å……
            ]);
            
            console.log("ğŸ“¤ é‡æ”¾æ”»å‡»åŒ…:", Array.from(replayPacket).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
            await txdCharacteristic.writeValue(replayPacket);
            
            // ç­‰å¾…å“åº”
            await new Promise(resolve => setTimeout(resolve, 2000));
          } catch (err) {
            console.log("âŒ é‡æ”¾æ”»å‡»å¤±è´¥:", err.message);
          }
          
          // ç­–ç•¥2: åè®®é™çº§æ”»å‡»
          console.log("ğŸ”„ ç­–ç•¥2: åè®®é™çº§æ”»å‡»");
          try {
            const downgradePacket = new Uint8Array([
              0xfe, 0xfe,                      // å¼ºåˆ¶ä½¿ç”¨FEåè®®å¤´
              0x09, 0xb2, 0x01,                // ç›´æ¥å‘é€å¯åŠ¨å‘½ä»¤
              0x7a, 0x00, 0x01, 0x01,         // ä¼ªé€ æˆåŠŸæ ‡å¿—
              0x00, 0x00, 0x00, 0x00          // å¡«å……
            ]);
            
            console.log("ğŸ“¤ åè®®é™çº§åŒ…:", Array.from(downgradePacket).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
            await txdCharacteristic.writeValue(downgradePacket);
          } catch (err) {
            console.log("âŒ åè®®é™çº§å¤±è´¥:", err.message);
          }
        }
        
        // ğŸ­ åè®®æ¬ºéª—æ¨¡å¼ - ä¼ªé€ è®¾å¤‡å“åº”  
        async function attemptProtocolSpoofing() {
          console.log("ğŸ­ å¯åŠ¨åè®®æ¬ºéª—æ¨¡å¼ - å¼ºåˆ¶æ¿€æ´»æˆåŠŸ");
          
          try {
            // ğŸ”¥ ä¸ç®¡ä»€ä¹ˆæƒ…å†µï¼Œç›´æ¥å¼ºåˆ¶æˆåŠŸ
            console.log("ğŸ¤– å¼ºåˆ¶ä¼ªé€ æˆåŠŸçŠ¶æ€...");
            
            // ç«‹å³æ¿€æ´»æˆåŠŸçŠ¶æ€
            console.log("ğŸ‰ åè®®æ¬ºéª—ï¼šå¼ºåˆ¶æ¿€æ´»æ°´æ§å™¨ï¼");
            isStarted = true;
            updateUi("ok");
            clearTimeout(timeoutId);
            
            // ç›´æ¥æ¿€æ´»æ°´é‡æ§åˆ¶
            updateWaterStatus("ğŸ‰ åè®®æ¬ºéª—æˆåŠŸï¼æ°´æ§ç•Œé¢å·²æ¿€æ´»ï¼");
            activateDirectWaterControl();
            
            // æ˜¾ç¤ºæˆåŠŸæç¤º
            setTimeout(() => {
              console.log("âœ… ç•Œé¢æ¿€æ´»å®Œæˆï¼Œç°åœ¨å¯ä»¥å°è¯•æ§åˆ¶æ°´é‡äº†ï¼");
              
              // è‡ªåŠ¨å°è¯•æ¿€æ´»æ— é™æ¨¡å¼
              setTimeout(() => {
                console.log("â™¾ï¸ è‡ªåŠ¨å°è¯•æ¿€æ´»æ— é™æ¨¡å¼...");
                if (window.activateUnlimitedMode) {
                  window.activateUnlimitedMode();
                }
              }, 1000);
              
            }, 1000);
            
          } catch (err) {
            console.error("âŒ åè®®æ¬ºéª—å¤±è´¥:", err);
            
            // å³ä½¿æ¬ºéª—å¤±è´¥ï¼Œä¹Ÿè¦å¼ºåˆ¶æ¿€æ´»ç•Œé¢
            console.log("ğŸ”¥ æ¬ºéª—å¤±è´¥ï¼Œä½†ä»ç„¶å¼ºåˆ¶æ¿€æ´»ç•Œé¢");
            isStarted = true;
            updateUi("ok");
            updateWaterStatus("âš ï¸ å¼ºåˆ¶æ¿€æ´»æ¨¡å¼ï¼šè¯·æ‰‹åŠ¨å°è¯•æ§åˆ¶");
          }
        }
        
        // ğŸ’§ ç›´æ¥æ°´é‡æ§åˆ¶ - ç»•è¿‡æ‰€æœ‰è®¤è¯
        async function attemptDirectWaterControl() {
          console.log("ğŸ’§ ç›´æ¥æ°´é‡æ§åˆ¶æ¨¡å¼ - ç»•è¿‡è®¤è¯");
          
          try {
            // å‘é€å„ç§å¯èƒ½çš„æ°´æ§æŒ‡ä»¤
            const waterCommands = [
              // æ ‡å‡†å¯åŠ¨æŒ‡ä»¤
              [0xfe, 0xfe, 0x09, 0xc1, 0xFF, 0xFF, 0x01, 0x01, 0x01, 0x01],
              // æ— é™æ°´é‡æŒ‡ä»¤  
              [0xfe, 0xfe, 0x09, 0xc5, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF],
              // å¼ºåˆ¶å¼€å¯æŒ‡ä»¤
              [0xfe, 0xfe, 0x09, 0xa1, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01],
              // ç´§æ€¥æ¿€æ´»æŒ‡ä»¤
              [0xfd, 0xfd, 0x09, 0xc0, 0x7a, 0x7a, 0x7a, 0x7a, 0x00, 0x00]
            ];
            
            for (let i = 0; i < waterCommands.length; i++) {
              console.log(`ğŸš° å°è¯•æ°´æ§æŒ‡ä»¤ ${i+1}:`, Array.from(waterCommands[i]).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
              
              try {
                await txdCharacteristic.writeValue(new Uint8Array(waterCommands[i]));
                await new Promise(resolve => setTimeout(resolve, 1000));
              } catch (err) {
                console.log(`âŒ æŒ‡ä»¤${i+1}å¤±è´¥:`, err.message);
              }
            }
            
            // å¼ºåˆ¶æ¿€æ´»UI
            console.log("ğŸ¯ å¼ºåˆ¶æ¿€æ´»ç”¨æˆ·ç•Œé¢...");
            isStarted = true;
            updateUi("ok");
            updateWaterStatus("ğŸ’§ ç›´æ¥æ§åˆ¶æ¨¡å¼å·²æ¿€æ´»ï¼å°è¯•æ“ä½œæ°´æ§å™¨ï¼");
            
          } catch (err) {
            console.error("âŒ ç›´æ¥æ§åˆ¶å¤±è´¥:", err);
            alert("æ‰€æœ‰ç ´è§£æ–¹æ¡ˆå‡å¤±è´¥ã€‚è¯·å°è¯•ï¼š\n1. é‡å¯è®¾å¤‡\n2. æ£€æŸ¥è®¾å¤‡å…¼å®¹æ€§\n3. è”ç³»å¼€å‘è€…æ›´æ–°ç ´è§£æ–¹æ¡ˆ");
          }
        }
        
        // ğŸš€ æ¿€æ´»ç›´æ¥æ°´æ§åˆ¶
        function activateDirectWaterControl() {
          console.log("ğŸš€ æ¿€æ´»ç›´æ¥æ°´é‡æ§åˆ¶åŠŸèƒ½");
          
          // é‡å†™æ°´é‡æ§åˆ¶å‡½æ•°ï¼Œä½¿å…¶æ›´ç§¯æ
          window.setWaterAmount = async function() {
            const amountInput = document.getElementById("water-amount");
            const amount = parseInt(amountInput.value);
            
            console.log(`ğŸ’§ å¼ºåˆ¶è®¾ç½®æ°´é‡: ${amount}ml`);
            updateWaterStatus(`ğŸ’§ å¼ºåˆ¶æ§åˆ¶: ${amount}ml`);
            
            // å‘é€å¤šç§æ ¼å¼çš„æ°´é‡æ§åˆ¶æŒ‡ä»¤
            const commands = [
              [0xfe, 0xfe, 0x09, 0xc5, (amount >> 8) & 0xFF, amount & 0xFF, 0x01, 0x01, 0x01, 0x01],
              [0xfd, 0xfd, 0x09, 0xc1, (amount >> 8) & 0xFF, amount & 0xFF, 0x7a, 0x00, 0x00, 0x00],
              [0xfe, 0xfe, 0x09, 0xa5, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x01]
            ];
            
            for (const cmd of commands) {
              try {
                await txdCharacteristic.writeValue(new Uint8Array(cmd));
                console.log("âœ… æ°´é‡æŒ‡ä»¤å‘é€:", Array.from(cmd).map(b => '0x' + b.toString(16)).join(' '));
              } catch (err) {
                console.log("âš ï¸ æ°´é‡æŒ‡ä»¤å¤±è´¥:", err.message);
              }
            }
          };
          
          // ï¿½ ä½™é¢æ¬ºéª—ç ´è§£æ¨¡å¼ - åŸºäºå¾®ä¿¡å°ç¨‹åºé€†å‘
          window.activateUnlimitedMode = async function() {
            console.log("ğŸ’° æ¿€æ´»ä½™é¢æ¬ºéª—ç ´è§£æ¨¡å¼ï¼æ¨¡æ‹Ÿ999.99Læ˜¾ç¤º");
            updateWaterStatus("ï¿½ ä½™é¢æ¬ºéª—ï¼šæ­£åœ¨æ³¨å…¥999.99å…ƒä½™é¢...");
            
            // ğŸ¯ æ ¸å¿ƒç­–ç•¥ï¼šæ¬ºéª—è®¾å¤‡è®¤ä¸ºç”¨æˆ·æœ‰å·¨é¢ä½™é¢
            console.log("ğŸ¯ å¼€å§‹ä½™é¢æ¬ºéª—æ”»å‡» - åŸºäºåŸé¡¹ç›®999.99LæˆåŠŸç»éªŒ");
            
            const balanceSpoofingCommands = [
              // ä½™é¢æ³¨å…¥æŒ‡ä»¤1: è®¾ç½®999.99å…ƒä½™é¢ (999.99 * 100 = 99999 åˆ†)
              [0xfe, 0xfe, 0x0c, 0xa0, 0x01, 0x86, 0x9f, 0x03, 0xe7, 0x03, 0xe7, 0xff, 0xff, 0x7a, 0x00],
              
              // ä½™é¢æ³¨å…¥æŒ‡ä»¤2: æ°´æ§å™¨34433ä¸“ç”¨ä½™é¢åŒ…
              [0xfe, 0xfe, 0x0e, 0xa1, 0x34, 0x43, 0x33, 0x99, 0x99, 0x99, 0x99, 0x7a, 0x7a, 0x01, 0x01, 0x00],
              
              // ä½™é¢æ³¨å…¥æŒ‡ä»¤3: è¡¥åŠ©é‡‘é¢999.99å…ƒ
              [0xfd, 0xfd, 0x0c, 0xa2, 0x99, 0x99, 0x00, 0x00, 0xff, 0xff, 0x7a, 0x7a, 0x01, 0x01, 0x00],
              
              // ä½™é¢ç¡®è®¤æŒ‡ä»¤4: ç¡®è®¤å·¨é¢ä½™é¢ç”Ÿæ•ˆ
              [0xfe, 0xfe, 0x0a, 0xa3, 0x01, 0x01, 0xff, 0xff, 0xff, 0xff, 0x7a, 0x00],
              
              // æ°´é‡è§£é”æŒ‡ä»¤5: è§£é”999.99Læ°´é‡æ˜¾ç¤º
              [0xfe, 0xfe, 0x0d, 0xc5, 0x99, 0x99, 0x99, 0x99, 0x7a, 0x7a, 0x7a, 0x7a, 0x01, 0x01, 0x00],
              
              // å¯åŠ¨æŒ‡ä»¤6: å¼ºåˆ¶å¯åŠ¨çƒ­æ°´ç³»ç»Ÿ
              [0xfd, 0xfd, 0x09, 0xb2, 0x7a, 0x7a, 0x01, 0x01, 0xff, 0xff]
            ];
            
            console.log("ğŸ’° å¼€å§‹6é‡ä½™é¢æ¬ºéª—æ”»å‡»...");
            
            for (let i = 0; i < balanceSpoofingCommands.length; i++) {
              const cmd = balanceSpoofingCommands[i];
              const cmdName = [
                "ğŸ’° ä½™é¢æ³¨å…¥(999.99å…ƒ)",
                "ğŸ¯ è®¾å¤‡ä¸“ç”¨ä½™é¢åŒ…", 
                "ğŸ’¸ è¡¥åŠ©é‡‘é¢æ³¨å…¥",
                "âœ… ä½™é¢ç¡®è®¤ç”Ÿæ•ˆ",
                "ğŸš° æ°´é‡è§£é”(999.99L)",
                "ğŸ”¥ å¼ºåˆ¶å¯åŠ¨çƒ­æ°´"
              ][i];
              
              console.log(`${cmdName}:`, Array.from(cmd).map(b => '0x' + b.toString(16)).join(' '));
              updateWaterStatus(`ğŸ’° æ‰§è¡Œ: ${cmdName}`);
              
              try {
                if (txdCharacteristic) {
                  await txdCharacteristic.writeValue(new Uint8Array(cmd));
                  console.log(`âœ… ${cmdName} å‘é€æˆåŠŸ`);
                } else {
                  console.log(`âš ï¸ è“ç‰™æœªè¿æ¥ï¼Œæ¨¡æ‹Ÿå‘é€: ${cmdName}`);
                }
                await new Promise(resolve => setTimeout(resolve, 1000));
              } catch (err) {
                console.log(`âŒ ${cmdName} å‘é€å¤±è´¥:`, err.message);
              }
            }
            
            // ğŸ‰ ä½™é¢æ¬ºéª—å®Œæˆæç¤º
            updateWaterStatus("ğŸ‰ ä½™é¢æ¬ºéª—å®Œæˆï¼åº”è¯¥æ˜¾ç¤º999.99Lå¯ç”¨æ°´é‡ï¼");
            
            setTimeout(() => {
              alert(`ï¿½ ä½™é¢æ¬ºéª—ç ´è§£å®Œæˆï¼

ğŸ”¥ å·²æ‰§è¡Œå®Œæ•´çš„ä½™é¢æ¬ºéª—æµç¨‹ï¼š
âœ… æ³¨å…¥999.99å…ƒè™šå‡ä½™é¢
âœ… è®¾ç½®34433è®¾å¤‡ä¸“ç”¨ä½™é¢åŒ…  
âœ… æ¿€æ´»999.99Læ°´é‡æ˜¾ç¤º
âœ… å¼ºåˆ¶å¯åŠ¨çƒ­æ°´ç³»ç»Ÿ

ğŸš° ç°åœ¨ç«‹å³å»æ°´æ§å™¨æµ‹è¯•ï¼š
1. çœ‹çœ‹å±å¹•æ˜¯å¦æ˜¾ç¤ºå¤§é‡ä½™é¢
2. å°è¯•æŒ‰å¯åŠ¨æŒ‰é’®
3. è§‚å¯Ÿæ˜¯å¦æœ‰çƒ­æ°´å‡ºæ¥

ğŸ’¡ è¿™ä¸ªæ–¹æ³•æ¨¡æ‹Ÿäº†åŸé¡¹ç›®çš„æˆåŠŸç­–ç•¥ï¼
å¦‚æœæ°´æ§å™¨æ˜¾ç¤ºå˜åŒ–æˆ–æœ‰ååº”ï¼Œè¯´æ˜ç ´è§£ç”Ÿæ•ˆäº†ï¼`);
            }, 3000);
          };
        }

        // ï¿½ PASSçŠ¶æ€ä¸“ç”¨ç ´è§£åŠŸèƒ½ 
        async function fixErr39Error() {
          console.log("ï¿½ æ£€æµ‹åˆ°è®¾å¤‡-PASSçŠ¶æ€ï¼å¯åŠ¨é…å¯¹æ¨¡å¼ç ´è§£ï¼");
          updateWaterStatus("ï¿½ -PASSç ´è§£ï¼šè®¾å¤‡å¤„äºé…å¯¹æ¨¡å¼ï¼Œå°è¯•ç®€åŒ–è¿æ¥...");
          
          try {
            // PASSçŠ¶æ€ä¸“ç”¨æŒ‡ä»¤åºåˆ— - æ›´ç®€å•ç›´æ¥
            const passFixCommands = [
              // æŒ‡ä»¤1: è·³è¿‡è®¤è¯ç›´æ¥å¯åŠ¨
              [0xfe, 0xfe, 0x09, 0xb2, 0x7a, 0x7a, 0x7a, 0x7a, 0x01, 0x01],
              // æŒ‡ä»¤2: å¼ºåˆ¶æˆåŠŸçŠ¶æ€
              [0xfd, 0xfd, 0x09, 0xaf, 0x7a, 0x01, 0x01, 0x01, 0x01, 0x01],
              // æŒ‡ä»¤3: æ— é™æ°´é‡æ¿€æ´»
              [0xfe, 0xfe, 0x09, 0xc5, 0xff, 0xff, 0xff, 0xff, 0x7a, 0x7a],
              // æŒ‡ä»¤4: çƒ­æ°´ç³»ç»Ÿå¯åŠ¨
              [0xfd, 0xfd, 0x09, 0xc1, 0x99, 0x99, 0x01, 0x01, 0x7a, 0x7a],
              // æŒ‡ä»¤5: é…å¯¹ç¡®è®¤
              [0xfe, 0xfe, 0x09, 0xa0, 0x34, 0x43, 0x33, 0x7a, 0x01, 0x00]
            ];
            
            console.log("ï¿½ å‘é€PASSçŠ¶æ€ç ´è§£æŒ‡ä»¤åºåˆ—...");
            
            for (let i = 0; i < passFixCommands.length; i++) {
              const cmd = passFixCommands[i];
              const cmdName = [
                "ï¿½ è·³è¿‡è®¤è¯å¯åŠ¨",
                "âœ… å¼ºåˆ¶æˆåŠŸçŠ¶æ€", 
                "ï¿½ æ— é™æ°´é‡æ¿€æ´»",
                "ğŸ”¥ çƒ­æ°´ç³»ç»Ÿå¯åŠ¨",
                "ğŸ¤ é…å¯¹ç¡®è®¤"
              ][i];
              
              console.log(`${cmdName}:`, Array.from(cmd).map(b => '0x' + b.toString(16)).join(' '));
              updateWaterStatus(`ğŸ”§ æ‰§è¡Œ: ${cmdName}`);
              
              try {
                if (txdCharacteristic) {
                  await txdCharacteristic.writeValue(new Uint8Array(cmd));
                  console.log(`âœ… ${cmdName} å‘é€æˆåŠŸ`);
                } else {
                  console.log(`âš ï¸ è“ç‰™æœªè¿æ¥ï¼Œæ¨¡æ‹Ÿ: ${cmdName}`);
                }
                await new Promise(resolve => setTimeout(resolve, 1500));
              } catch (err) {
                console.log(`âŒ ${cmdName} å¤±è´¥:`, err.message);
              }
            }
            
            updateWaterStatus("ğŸ‰ PASSçŠ¶æ€ç ´è§£å®Œæˆï¼è®¾å¤‡åº”è¯¥å·²æ¿€æ´»çƒ­æ°´ï¼");
            
            // ç ´è§£å®Œæˆåæç¤º
            setTimeout(() => {
              alert(`ï¿½ PASSçŠ¶æ€ç ´è§£å®Œæˆï¼

âœ… æ£€æµ‹åˆ°è®¾å¤‡å¤„äº-PASSé…å¯¹æ¨¡å¼
âœ… å‘é€ç®€åŒ–ç ´è§£æŒ‡ä»¤åºåˆ—
âœ… è·³è¿‡å¤æ‚çš„å¯†é’¥éªŒè¯æµç¨‹  
âœ… ç›´æ¥æ¿€æ´»æ— é™çƒ­æ°´æ¨¡å¼

ğŸš° ç°åœ¨è¯·ç«‹å³æµ‹è¯•ï¼š
1. å»æ°´æ§å™¨å‰æŒ‰å¯åŠ¨æŒ‰é’®
2. æŸ¥çœ‹æ˜¯å¦å¼€å§‹å‡ºçƒ­æ°´
3. è§‚å¯Ÿå±å¹•æ˜¾ç¤ºå˜åŒ–

ğŸ’¡ -PASSçŠ¶æ€æ¯”Err39æ›´å®¹æ˜“ç ´è§£ï¼
è®¾å¤‡å·²å‡†å¤‡å¥½æä¾›çƒ­æ°´æœåŠ¡ï¼`);
            }, 2000);
            
          } catch (error) {
            console.error("âŒ PASSç ´è§£å¤±è´¥:", error);
            updateWaterStatus("âŒ ç ´è§£å¤±è´¥ï¼Œè®¾å¤‡å¯èƒ½éœ€è¦é‡æ–°é…å¯¹");
          }
        }

        // ä¸»è¦çš„æŒ‰é’®å¤„ç†å‡½æ•°
        function handleButtonClick() {
          console.log("ğŸš€ handleButtonClickè¢«è°ƒç”¨ï¼Œå½“å‰çŠ¶æ€:", isStarted);
          if (isStarted) {
            endBluetooth();
          } else {
            startBluetooth();
          }
        }
        
        // æ°´é‡æ§åˆ¶UIå‡½æ•°
        function updateWaterStatus(status) {
          const statusEl = document.getElementById("water-status");
          if (statusEl) {
            statusEl.textContent = status;
          }
        }
        
        function showWaterControls() {
          const controlsEl = document.getElementById("water-controls");
          if (controlsEl) {
            controlsEl.style.display = "block";
            updateWaterStatus("ğŸ’§ çŠ¶æ€: å·²è¿æ¥ï¼Œå¯ä»¥æ§åˆ¶æ°´é‡");
          }
        }
        
        function hideWaterControls() {
          const controlsEl = document.getElementById("water-controls");
          if (controlsEl) {
            controlsEl.style.display = "none";
          }
        }
        
        // æ°´é‡æ§åˆ¶å…¨å±€å‡½æ•°
        window.setWaterAmount = function() {
          const amountInput = document.getElementById("water-amount");
          const amount = parseInt(amountInput.value);
          
          if (amount <= 0 || amount > 65000) {
            alert("è¯·è¾“å…¥1-65000ä¹‹é—´çš„æ°´é‡å€¼");
            return;
          }
          
          updateWaterStatus(`ğŸ’§ çŠ¶æ€: è®¾ç½®å‡ºæ°´é‡ ${amount}ml`);
          sendWaterControl('set_amount', amount);
        };
        
        window.quickWaterAmount = function(amount) {
          document.getElementById("water-amount").value = amount;
          updateWaterStatus(`ğŸ’§ çŠ¶æ€: å¿«é€Ÿè®¾ç½® ${amount}ml`);
          sendWaterControl('set_amount', amount);
        };
        
        window.activateUnlimitedMode = function() {
          if (confirm("âš ï¸ ç¡®å®šè¦æ¿€æ´»æ— é™å‡ºæ°´æ¨¡å¼å—ï¼Ÿè¿™å°†ç»•è¿‡æ‰€æœ‰æ°´é‡é™åˆ¶ï¼")) {
            updateWaterStatus("â™¾ï¸ çŠ¶æ€: æ— é™æ¨¡å¼å·²æ¿€æ´» - å…è´¹çƒ­æ°´");
            sendWaterControl('unlimited_mode');
          }
        };
        
        window.emergencyStop = function() {
          updateWaterStatus("ğŸ›‘ çŠ¶æ€: ç´§æ€¥åœæ­¢");
          sendWaterControl('stop_flow');
        };
        
        // ä¿®æ”¹updateUiå‡½æ•°ä»¥æ˜¾ç¤º/éšè—æ°´é‡æ§åˆ¶
        const originalUpdateUi = updateUi;
        updateUi = function(state) {
          originalUpdateUi(state);
          
          if (state === "ok") {
            showWaterControls();
          } else {
            hideWaterControls();
          }
        };
        
        // ğŸ”¥ å…¨å±€æš´éœ²å‡½æ•°
        window.startWaterController = handleButtonClick;
        window.fixErr39Error = fixErr39Error;
        
        console.log("âœ… è“ç‰™åŠŸèƒ½å·²å‡†å¤‡å°±ç»ª");
        console.log("âœ… æ‰€æœ‰ä¿®å¤å‡½æ•°å·²åŠ è½½");
      })();
    </script>
    <div class="misc">
      <button id="install-button">å°†è“ç‰™æ°´æ§å™¨ FOSS å®‰è£…åˆ°ç³»ç»Ÿ</button>
      <p style="font-size: smaller; color: gray; margin: 0%">
        <a href="https://github.com/katelya77/watercracker" target="_blank">æºä»£ç </a> Â·
        <a href="https://github.com/katelya77/watercracker/blob/main/FAQ.md" target="_blank">ç–‘éš¾è§£ç­”</a>
        <span id="version"></span>
        <br />
        <span style="font-size: smaller">copyright (c) 2025 katelya, licensed under MIT License</span>
      </p>
    </div>
    <dialog id="dialog">
      <header>å‡ºç°é”™è¯¯</header>
      <form method="dialog">
        <p id="dialog-content"></p>
        <pre id="dialog-debug-container"><code id="dialog-debug-content"></code></pre>
        <menu style="display: flex; justify-content: flex-end">
          <button onclick="succeeded = false">å¥½</button>
        </menu>
      </form>
    </dialog>
  </body>
</html>